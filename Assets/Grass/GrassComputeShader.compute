// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
struct Transform
{
    float3 worldPosition;
    float2 facing;
    float windFactor;
    float width;
    float height;
};

AppendStructuredBuffer<Transform> _GrassTransforms;
RWStructuredBuffer<float2> _GrassWindValues;
Texture2D<float> _AmbientWindMap;

float _DeltaTime;
float _RandomSeed;

float2 _AmbientWindMapSize;
float3 _AmbientWindCenter;
float _AmbientWindSize;
float _AmbientWindStrength;
float _WindDissipation;
float2 _AmbientWindDirection;

float3 _TileCenter;
float _TileSize;
float _TileDensity;
float _TrueGrassCount;
float _GrassOffsetStrength;
float4 _GrassScalingRange;

float2 _GrassDefaultFacing;
float _GrassFacingRandomness;

//random value generator 2d to 2d
//https://www.shadertoy.com/view/XlGcRh
uint2 pcg2d(uint2 v)
{
    v = v * 1664525u + 1013904223u;

    v.x += v.y * 1664525u;
    v.y += v.x * 1664525u;

    v = v ^ (v>>16u);

    v.x += v.y * 1664525u;
    v.y += v.x * 1664525u;

    v = v ^ (v>>16u);

    return v;
}

float SampleAmbientWindBilepr(float3 grassPos)
{
    float2 texUV = ((grassPos - _AmbientWindCenter).xz / _AmbientWindSize) + 0.5;
    float2 pos = texUV * _AmbientWindMapSize; 
    int2 floorPos = pos;
    float2 blend = pos - floorPos;

    float xL = _AmbientWindMap[(floorPos)];
    float xR = _AmbientWindMap[(floorPos + int2(1, 0))];
    float xB = _AmbientWindMap[(floorPos + int2(0, 1))];
    float xT = _AmbientWindMap[(floorPos + int2(1, 1))];
    
    float col_x = lerp(xL, xR, blend.x);
    float col_y = lerp(xB, xT, blend.x);
    return lerp(col_x, col_y, blend.y);
}

float easeOutOffset(float x, float power, float offset)
{
    return (1.0 - offset) * (1 - pow(1 - x, power)) + offset;
}

[numthreads(16,16,1)]
void CSMain (uint2 id : SV_DispatchThreadID, uint2 groupID : SV_GroupThreadID)
{
    Transform newTransform;

    float2 pos = id.xy / (_TileDensity - 1);
    float2 randomPos = (pcg2d(id) % 100) / 100.0;
    float2 idPos = (pos.xy * 2 - 1) * (_TileSize * 0.5) + (randomPos * _GrassOffsetStrength);
    newTransform.worldPosition = float3(idPos.x, 0, idPos.y);

    float2 randomRot = (pcg2d(id*73) % 100) / 100.0;
    float2 randomFacing = normalize(randomRot * 2.0 - 1.0);
    newTransform.facing = lerp(_GrassDefaultFacing, randomFacing, _GrassFacingRandomness);

    int bufferIndex = id.x + id.y * _TileDensity;
    float2 ambientWind = _AmbientWindDirection * SampleAmbientWindBilepr(newTransform.worldPosition);
    float windFacingDot = dot(newTransform.facing, ambientWind);

    _GrassWindValues[bufferIndex] *= lerp(_WindDissipation, 1.0, abs(windFacingDot));
    _GrassWindValues[bufferIndex].x += sign(windFacingDot) * easeOutOffset(abs(windFacingDot), 4, 0.3) * _AmbientWindStrength * 0.01;
    //_GrassWindValues[bufferIndex].x = lerp(oldWindValue.x, newWindFactor, (abs(newWindFactor - oldWindValue) < 0.01) ? 1.0 : _DeltaTime);
    //float prevCurrWindDot = dot(normalize(ambientWind), normalize(prevAmbientWind));
    //_GrassWindValues[bufferIndex] *= _WindDissipation;
    //_GrassWindValues[bufferIndex] = lerp(prevAmbientWind, ambientWind, (prevCurrWindDot > 0.99) ? 1.0 : _DeltaTime);
    //_GrassWindValues[bufferIndex] = ambientWind;
 
    
    
    float2 randomScaling = (pcg2d(id*57) % 100) / 100.0;
    newTransform.width = lerp(_GrassScalingRange.x, _GrassScalingRange.y, randomScaling.x);
    newTransform.height = lerp(_GrassScalingRange.z, _GrassScalingRange.w, randomScaling.y);
   
    newTransform.windFactor = _GrassWindValues[bufferIndex].x;

    if (id.x >= _TileDensity || id.y >= _TileDensity)
        return;
    
    _GrassTransforms.Append(newTransform);
}

#pragma kernel BlitWindValuesToTex

RWTexture2D<float2> _WindValuesTexture;

[numthreads(16,16,1)]
void BlitWindValuesToTex (uint2 id : SV_DispatchThreadID, uint2 groupID : SV_GroupThreadID)
{
    int bufferIndex = id.x + id.y * _TileDensity;
    _WindValuesTexture[id] = _GrassWindValues[bufferIndex];
}