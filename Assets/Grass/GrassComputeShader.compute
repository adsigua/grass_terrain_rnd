// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "grass_utils.hlsl"
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

AppendStructuredBuffer<Transform> _GrassTransforms;
RWStructuredBuffer<float4> _GrassWindValues;

uniform StructuredBuffer<TerrainData> _TerrainDataBuffer;
uniform float _TerrainBufferWidth;
uniform float _TerrainSize;
uniform float3 _TerrainCenter;

float _DeltaTime;
float _Time;
float _RandomSeed;

Texture2D<float> _AmbientWindMap;
float2 _AmbientWindMapSize;
Texture2D<float3> _FluidMap;
float2 _FluidMapSize;
float3 _AmbientWindCenter;
float _AmbientWindSize;
float2 _AmbientWindStrength;
float _WindDissipation;
float _GrassWindEffect;
float2 _AmbientWindDirection;
float _FluidMapWindStrength;

float3 _TileCenter;
float _TileSize;
float _TileDensity;
float _TrueGrassCount;
float _GrassOffsetStrength;
float4 _GrassScalingRange;

float2 _GrassDefaultFacing;
float _GrassFacingRandomness;
float _GrassTilt;
float _GrassFlutter;
float _GrassStiffness;
float _GrassBend;
float _GrassBendPos;

float _ValueHolderA;
float _ValueHolderB;
float _ValueHolderC;

float SampleAmbientWindBilepr(float3 grassPos)
{
    float2 texUV = ((grassPos.xz - _AmbientWindCenter.xz) / _AmbientWindSize) + 0.5;
    float2 pos = texUV * _AmbientWindMapSize; 
    int2 floorPos = pos;
    float2 blend = pos - floorPos;

    float xL = _AmbientWindMap[(floorPos)];
    float xR = _AmbientWindMap[(floorPos + int2(1, 0))];
    float xB = _AmbientWindMap[(floorPos + int2(0, 1))];
    float xT = _AmbientWindMap[(floorPos + int2(1, 1))];
    
    float col_x = lerp(xL, xR, blend.x);
    float col_y = lerp(xB, xT, blend.x);
    return lerp(col_x, col_y, blend.y);
}

float3 SampleFluidMapWindBilepr(float3 grassPos)
{
    float2 texUV = ((grassPos.xz - _AmbientWindCenter.xz) / _AmbientWindSize) + 0.5;
    float2 pos = texUV * _FluidMapSize; 
    int2 floorPos = pos;
    float2 blend = pos - floorPos;

    float3 xL = _FluidMap[(floorPos)];
    float3 xR = _FluidMap[(floorPos + int2(1, 0))];
    float3 xB = _FluidMap[(floorPos + int2(0, 1))];
    float3 xT = _FluidMap[(floorPos + int2(1, 1))];
    
    float3 col_x = lerp(xL, xR, blend.x);
    float3 col_y = lerp(xB, xT, blend.x);
    return lerp(col_x, col_y, blend.y);
}

int getPosBufferIndex(int2 id)
{
    return id.x + id.y * _TerrainBufferWidth;
}

TerrainData SampleTerrainBufferBilerp(float2 posXZ)
{
    float2 uv = ((posXZ - _TerrainCenter.xz) / _TerrainSize) + 0.5;
    float2 texelPos = uv * _TerrainBufferWidth;
    int2 floorPos = texelPos;
    float2 blend = texelPos - floorPos;

    TerrainData xL = _TerrainDataBuffer[getPosBufferIndex(floorPos)];
    TerrainData xR = _TerrainDataBuffer[getPosBufferIndex(floorPos + int2(1.0, 0.0))];
    TerrainData xB = _TerrainDataBuffer[getPosBufferIndex(floorPos + int2(0.0, 1.0))];
    TerrainData xT = _TerrainDataBuffer[getPosBufferIndex(floorPos + int2(1.0, 1.0))];
    
    float3 normalX = lerp(xL.normal, xR.normal, blend.x);
    float3 normalY = lerp(xB.normal, xT.normal, blend.x);

    float3 tangentX = lerp(xL.tangent, xR.tangent, blend.x);
    float3 tangentY = lerp(xB.tangent, xT.tangent, blend.x);

    float heightX = lerp(xL.height, xR.height, blend.x);
    float heightY = lerp(xB.height, xT.height, blend.x);

    TerrainData td;
    td.height = lerp(heightX, heightY, blend.y);
    td.normal = lerp(normalX, normalY, blend.y);
    td.tangent = lerp(tangentX, tangentY, blend.y);
    return td;
}

float getFlutterValue(float t, float offset)
{
    float curveVal = -4.0 * (t - 0.5) * (t - 0.5) + 1.0;
    return offset * (1.0 - curveVal) + curveVal;
}
            
float4 computeMidAndTipValues(int bufferIndex, float hashVal)
{
    float ambientWind = _GrassWindValues[bufferIndex].x;
    float2 normWind = _AmbientWindStrength / 24.0f;
    float windSign = sign(ambientWind);
    float windValue =  saturate(lerp(normWind.x, normWind.y, abs(ambientWind))) * windSign;
    float absWindValue = abs(windValue);
    half flutterSpeed = max(2, 8 * absWindValue);
    half flutterStrength = 0.3;
    half windFlutter = getFlutterValue(windValue, 0.4) * flutterStrength;
    
    float tipTime = _GrassWindValues[bufferIndex].y + (_DeltaTime * flutterSpeed * _ValueHolderA);
    _GrassWindValues[bufferIndex].y = tipTime;
    float normFlutter = sin(tipTime + hashVal) * 0.5 + lerp(0.2, 0.5, windValue);
    
    float2 tipPoint = lerp(float2(_GrassTilt, 1.0 - _GrassTilt), float2(windSign, 0.1), absWindValue + normFlutter * windFlutter * _GrassFlutter);
    
    float easeWindValue = easeIn(absWindValue, 3);
    float2 orthoDir = float2(tipPoint.y, -tipPoint.x);
    
    //1.75 = 0.875(valueC) * 2.0
    float bendNorm = sin(tipTime + hashVal + 1.75) * 0.6 - 0.4;
    bendNorm = bendNorm * lerp(0.05, 1.0, easeWindValue);
    float bendValue = lerp(_GrassBend * lerp(-0.2, bendNorm, saturate(_GrassFlutter/0.1)), 0.1 * bendNorm, easeWindValue) * (lerp(4, 0, _GrassStiffness));
    float2 midPoint = normalize(tipPoint) * _GrassBendPos + orthoDir * bendValue;
    return float4(midPoint, tipPoint);
}

[numthreads(16,16,1)]
void CSMain (uint2 id : SV_DispatchThreadID, uint2 groupID : SV_GroupThreadID)
{
    Transform newTransform;

    half2 pos = id.xy / (_TileDensity - 1);
    float2 randomPos = (pcg2d(id) % 100) / 100.0;
    float2 idPos = (pos.xy * 2 - 1) * (_TileSize * 0.5) + (randomPos * _GrassOffsetStrength);
    newTransform.position = float3(idPos.x, 0, idPos.y);

    float2 randomRot = (pcg2d(id*73) % 100) / 100.0;
    float2 randomFacing = normalize(randomRot * 2.0 - 1.0);
    float2 facing = lerp(_GrassDefaultFacing, randomFacing, _GrassFacingRandomness);

    int bufferIndex = id.x + id.y * _TileDensity;
    float2 uvPos = ((newTransform.position.xz - _AmbientWindCenter.xz) / _AmbientWindSize) + 0.5;
    //float windVal = SampleAmbientWindBilepr(newTransform.position);
    float windVal = _AmbientWindMap[uvPos * _AmbientWindMapSize];
    
    float2 ambientWind = _AmbientWindDirection * windVal;
    float3 fluidSample = SampleFluidMapWindBilepr(newTransform.position);
    float2 fluidMapWind = fluidSample.xy * fluidSample.z;
    
    float windFacingDot = dot(facing, ambientWind);
    float fluidFacingDot = dot(facing, fluidMapWind);
    
    //_GrassWindValues[bufferIndex].y = _GrassWindValues[bufferIndex].x;
    //_GrassWindValues[bufferIndex].x = lerp(_GrassWindValues[bufferIndex].y, windFacingDot, _WindDissipation);
    //_GrassWindValues[bufferIndex].x = lerp(_GrassWindValues[bufferIndex].y, windVal, _WindDissipation);
    _GrassWindValues[bufferIndex].x *= lerp(_WindDissipation, 1.0, abs(windFacingDot));
    _GrassWindValues[bufferIndex].x = clamp(_GrassWindValues[bufferIndex].x + windFacingDot * _GrassWindEffect, -1.0, 1.0);
    //_GrassWindValues[bufferIndex].x = windVal;
    
    if (id.x >= _TileDensity || id.y >= _TileDensity)
        return;

    float3 randomValues = (pcg3d(newTransform.position) % 100) / 100.0;

    float4 miAndTipValues = computeMidAndTipValues(bufferIndex, randomValues.x * 73);
    newTransform.bezierMidPoint = miAndTipValues.xy;
    newTransform.bezierEndPoint = miAndTipValues.zw;

    TerrainData td = SampleTerrainBufferBilerp(_TileCenter.xz + newTransform.position.xz);
    
    newTransform.position.y = td.height;
    
    float3x3 facingRotMat = getFacingRotation(facing);
    //newTransform.rotation = mul(facingRotMat, tiltRotMat);
    newTransform.rotation = facingRotMat;
    
    float2 randomScaling = (pcg2d(id*57) % 100) / 100.0;
    newTransform.width = lerp(_GrassScalingRange.x, _GrassScalingRange.y, randomScaling.x);
    newTransform.height = lerp(_GrassScalingRange.z, _GrassScalingRange.w, randomScaling.y);
   
    newTransform.windFactor = _GrassWindValues[bufferIndex].x;
    
    _GrassTransforms.Append(newTransform);
}

#pragma kernel BlitWindValuesToTex

RWTexture2D<float2> _WindValuesTexture;

[numthreads(16,16,1)]
void BlitWindValuesToTex (uint2 id : SV_DispatchThreadID, uint2 groupID : SV_GroupThreadID)
{
    int bufferIndex = id.x + id.y * _TileDensity;
    _WindValuesTexture[id] = _GrassWindValues[bufferIndex];
}